library(AppliedPredictiveModeling)
data(segmentationOriginal)
library(caret)
training <- segmentationOriginal[Case == "Test",]
training <- segmentationOriginal[segmentationOriginal$Case == "Test",]
set.seed(125)
modFit <- train(Class ~ ., method="rpart",data=training)
print(modFit$finalModel)
training <- segmentationOriginal[segmentationOriginal$Case == "Train",]
modFit <- train(Class ~ ., method="rpart",data=training)
test <- segmentationOriginal[segmentationOriginal$Case == "Test",]
test
test[test$TotalIntench2 == 23,000]
test[TotalIntench2 == 23,000]
test
test$TotalIntenCh2
test[test$TotalIntenCh2==23000,]
test[107]
test[test$TotalInTench2]
test[test$TotalInTench2==23000,]
test[test$TotalIntench2 == 23000,]
test$TotalIntench2
test <- segmentationOriginal[segmentationOriginal$Case == "Test",]
test$TotalIntench2
test$TotalIntenCh2
order(test$TotalIntenCh2)
test <- segmentationOriginal[segmentationOriginal$Case == "Test",]
plot(modFit$finalModel, uniform = TRUE, main = "Classification Tree")
fancyRpartPlot(modFit$finalModel)
library(rattle)
install.packages("rattle")
fancyRpartPlot(modFit$finalModel)
print(modFit$finalModel)
plot(modFit$finalModel)
plot(modFit$finalModel, uniform = TRUE, main = "Classification Tree")
text(modFit$finalModel,use.n=TRUE,all=TRUE)
library(pgmm)
install.packages("pgmn")
data(olive)
load("~/Downloads/olive.rda")
data(olive)
olive = olive[,-1]
modFit <- train(Area ~ .,method="rpart",data=olive)
library(caret)
modFit <- train(Area ~ .,method="rpart",data=olive)
print(modFit$finalModel)
newdata = as.data.frame(t(colMeans(olive)))
predict(modFit,newdata)
modFit <- train(Area ~ .,method="rpart2",data=olive)
predict(modFit,newdata)
library(ElemStatLearn)
install.packages("ElemStatLearn")
library(ElemStatLearn)
data(SAheart)
set.seed(8484)
train = sample(1:dim(SAheart)[1],size=dim(SAheart)[1]/2,replace=F)
trainSA = SAheart[train,]
testSA = SAheart[-train,]
set.seed(13234)
modFit <-train(chd ~ age + alcohol + obesity + tobacco + typea + ldl,method="glm",family="binomial",data=trainSA)
missClass = function(values,prediction){sum(((prediction > 0.5)*1) != values)/length(values)}
missClass((trainSA,predict(modFit,trainSA)))
missClass(trainSA,predict(modFit,trainSA))
missClass(testSA,predict(modFit,testSA))
missClass(testSA$chd,predict(modFit,testSA))
missClass(trainSA$chd,predict(modFit,trainSA))
library(ElemStatLearn)
data(vowel.train)
data(vowel.test)
vowel.train$y <- factor(vowel.train$y)
vowel.test$y <- factor(vowel.test$y)
set.seed(33833)
library(caret)
mmodFit1 <- train(y ~ ., data=vowel.train, method="rf",proximity=TRUE)
mmodFit2 <- train(y ~ ., data=vowel.train, method="gbm")
pred1 <- predict(modFit1,vowel.test)
pred1 <- predict(mmodFit1,vowel.test)
table(pred1,vowel.test$y)
pred1
mmodFit1
modFit2
mmodFit2
# create models
fit1 <- train(y ~ ., data = vowel.train, method = "rf", trControl = trainControl(number = 4))
fit2 <- train(y ~ ., data = vowel.train, method = "gbm")
# predict test
predict1 <- predict(fit1, newdata = vowel.test)
predict2 <- predict(fit2, newdata = vowel.test)
# combine predictions
DF_combined <- data.frame(predict1, predict2, y = vowel.test$y)
fit_combined <- train(y ~ ., data = DF_combined, method = "gam")
predict3 <- predict(fit_combined, newdata = vowel.test)
# confusion matrixes
c1 <- confusionMatrix(predict1, vowel.test$y)
c2 <- confusionMatrix(predict2, vowel.test$y)
c3 <- confusionMatrix(predict3, DF_combined$y)
c3
c1
pred1 <- predict(mmodFit1,vowel.test$y)
mmodFit1 <- train(y ~ ., data=vowel.train, method="rf",proximity=TRUE)
pred1 <- predict(mmodFit1,vowel.test$y)
?predict
pred1 <- predict(mmodFit1,vowel.test)
c1 <- confusionMatrix(pred1,vowel.test$y)
c1
mmodFit1 <- train(y ~ ., data=vowel.train, method="rf")
pred1 <- predict(mmodFit1,vowel.test)
c1 <- confusionMatrix(pred1,vowel.test$y)
c1
c2
library(caret)
library(gbm)
set.seed(3433)
library(AppliedPredictiveModeling)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
set.seed(62433)
modFit1 < train(diagnosis ~ .,data=training,method="rf")
modFit1 <- train(diagnosis ~ .,data=training,method="rf")
modFit2 <- train(diagnosis ~ .,data=training,method="gbm")
modFit3 <- train(diagnosis ~ .,data=training,method="lda")
modFit3
pred1 <- predict(modFit1,testing)
pred2 <- predict(modFit2,testing)
pred3 <- predict(modFit3,testing)
pred <- data.frame(pred1,pred2,pred3,diagnosis=testing$diagnosis)
combModFit <- train(diagnosis ~ .,data=pred,method="rf")
combModFit
modFit1$accuracy
modFit1$Accuracy
modFit1
modFit2
modFit3
combModFit
modFit1$finalModel
confusionMatrix(modFit1)
confusionMatrix(modFit2)
confusionMatrix(modFit3)
confusionMatrix(combModFit)
set.seed(62433)
# create models
fit1 <- train(diagnosis ~ ., data = training, method = "rf", trControl = trainControl(number = 4))
fit2 <- train(diagnosis ~ ., data = training, method = "gbm")
fit3 <- train(diagnosis ~ ., data = training, method = "lda")
# predict test
predict1 <- predict(fit1, newdata = testing)
predict2 <- predict(fit2, newdata = testing)
predict3 <- predict(fit3, newdata = testing)
# combine predictions
DF_combined <- data.frame(predict1, predict2, predict3, diagnosis = testing$diagnosis) # training$diagnosis?
fit_combined <- train(diagnosis ~ ., data = DF_combined, method = "rf")
predict4 <- predict(fit_combined, newdata = testing)
# confusion matrixes
c1 <- confusionMatrix(predict1, testing$diagnosis)
c2 <- confusionMatrix(predict2, testing$diagnosis)
c3 <- confusionMatrix(predict3, testing$diagnosis)
c4 <- confusionMatrix(predict4, testing$diagnosis)
print(paste(c1$overall[1], c2$overall[1], c3$overall[1], c4$overall[1]))
set.seed(3523)
library(AppliedPredictiveModeling)
data(concrete)
inTrain = createDataPartition(concrete$CompressiveStrength, p = 3/4)[[1]]
training = concrete[ inTrain,]
testing = concrete[-inTrain,]
set.seed(233)
?train
modFit <- train(CompressiveStrength ~ . ,method="lasso",data=training)
modFit
?plot.enet
plot.enet(modFit)
plot.enet(modFit,xvar="penalty")
plot(modFit)
plot(modFit,xvar="penalty")
plot.enet(modFit$finalModel, xvar = "penalty", use.color = TRUE)
gaData <- read.csv("~/Desktop/gaData.csv")
View(gaData)
library(lubridate)  # For year() function below
dat = read.csv("~/Desktop/gaData.csv")
training = dat[year(dat$date) < 2012,]
testing = dat[(year(dat$date)) > 2011,]
tstrain = ts(training$visitsTumblr)
install.packages("lubridate")
library(lubridate)  # For year() function below
dat = read.csv("~/Desktop/gaData.csv")
training = dat[year(dat$date) < 2012,]
testing = dat[(year(dat$date)) > 2011,]
tstrain = ts(training$visitsTumblr)
?bats
install.packages("forecast")
?bats
?forecast
library("forecast", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
View(training)
modFit <- bats(visitsTumblr)
modFit <- bats(training$visitsTumblr)
View(testing)
View(training)
forecast(modFit)
accuracy(forecast(modFit),testing)
fcast <- forecast(modFit)
accuracy(fcast,testing)
accuracy(fcast)
fcast <- forecast(fit, level = 95, h = h)
fcast <- forecast(modFit, level = 95, h = h)
fcast <- forecast(modFit, level = 95)
fit <- bats(tstrain)
fcast <- forecast(fit, level = 95)
accuracy(fcast, testing$visitsTumblr)
result <- c()
l <- length(fcast$lower)
for (i in 1:l){
x <- testing$visitsTumblr[i]
a <- fcast$lower[i] < x & x < fcast$upper[i]
result <- c(result, a)
}
sum(result)/l * 100
facst
fcast
result
fcast <- forecast(fit)
accuracy(fcast, testing$visitsTumblr)
result <- c()
l <- length(fcast$lower)
for (i in 1:l){
x <- testing$visitsTumblr[i]
a <- fcast$lower[i] < x & x < fcast$upper[i]
result <- c(result, a)
}
sum(result)/l * 100
set.seed(3523)
library(AppliedPredictiveModeling)
data(concrete)
inTrain = createDataPartition(concrete$CompressiveStrength, p = 3/4)[[1]]
training = concrete[ inTrain,]
testing = concrete[-inTrain,]
set.seed(325)
modFit <-(CompressiveStrength ~.,method="svm",data=training)
modFit <- train(CompressiveStrength ~.,method="svm",data=training)
library("e1071", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
fit <- train(CompressiveStrength ~ ., data = training, method = "svmRadial")
pred <- predict(fit,testing)
accuracy(pred,testing$CompressiveStrength)
load("~/Dropbox/RAssignments/PracticalMachineLearning/WorkInProgress.RData")
load("~/Dropbox/RAssignments/PracticalMachineLearning/WorkInProgress.RData")
inTrain = createDataPartition(training$classe, p = 0.6)
training = training[ inTrain,]
testing = training[-inTrain,]
library(caret)
inTrain = createDataPartition(training$classe, p = 0.6)
training = training[ inTrain,]
testing = training[-inTrain,]
inTrain = createDataPartition(training$classe, p = 0.6,list=FALSE)
training = training[ inTrain,]
testing = training[-inTrain,]
set.seed(123)
modFit <- train(classe ~ ., data=training,method="rf",ntree=100, proximity=TRUE,do.trace=TRUE)
filter <- rawtraining[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
if(!file.exists("pml-training.csv")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv"
download.file(fileUrl, destfile="pml-training.csv",method="curl")
}
if (!exists("rawtraining"))
rawtraining <- read.csv("pml-training.csv")
filter <- rawtraining[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
filter <- rawtraining[colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining),]
colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)
testing <- rawtraining[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
training <- rawtraining[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
library(caret)
library(caret)
inTrain = createDataPartition(training$classe, p = 0.1,list=FALSE)
training = training[ inTrain,]
validation = training[-inTrain,]
set.seed(123)
modFit <- train(classe ~ ., data=training,method="rf",ntree=50, proximity=TRUE,do.trace=TRUE)
if(!file.exists("pml-training.csv")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv"
download.file(fileUrl, destfile="pml-training.csv",method="curl")
}
if (!exists("rawtraining"))
rawtraining <- read.csv("pml-training.csv")
if(!file.exists("pml-test.csv")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv"
download.file(fileUrl, destfile="pml-testing.csv",method="curl")
}
if (!exists("testing"))
testing <- read.csv("pml-testing.csv")
training <- rawtraining[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
testing <- testing[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
testing <- read.csv("pml-testing.csv")
testing <- testing[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
if(!file.exists("pml-training.csv")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv"
download.file(fileUrl, destfile="pml-training.csv",method="curl")
}
if (!exists("rawtraining"))
rawtraining <- read.csv("pml-training.csv")
if(!file.exists("pml-test.csv")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv"
download.file(fileUrl, destfile="pml-testing.csv",method="curl")
}
if (!exists("testing"))
testing <- read.csv("pml-testing.csv")
training <- rawtraining[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
testing <- testing[,colSums(is.na(rawtraining)) < 0.97 * nrow(rawtraining)]
library(manipulate)
myPlot <- function(s) {
plot(cars$dist - mean(cars$dist), cars$speed - mean(cars$speed))
abline(0, s)
}
manipulate(myPlot(s), slider = x(0, 2, step = 0.1))
manipulate(myPlot, s = slider(0, 2, step = 0.1))
manipulate(myPlot(s), x.s = slider(0, 2, step = 0.1))
manipulate(myPlot(s), s = slider(0, 2, step = 0.1))
library(rcharts)
install.packages("rcharts")
library(rcharts)
airquality
d <- data.frame(airquality, stringsAsFactors = FALSE) print(d)
dTable(airquality, sPaginationType = "full_numbers")
?dTable
library(devtools)
install_github("ramnathv/rCharts@dev")
install.packages("devtools")
library(devtools)
install_github("ramnathv/rCharts@dev")
install.packages("base64enc")
library(devtools)
install_github("ramnathv/rCharts@dev")
?lm
isGeneric(lm)
isGeneric('lm')
isGeneric('predict')
isGeneric('ColSims')
isGeneric('ColSums')
isGeneric('dgamma')
install.packages('DDPQuiz3')
createmean
show
show createmean
showMethods("createmean")
methods(createmean)
install.packages('DDPQuiz3')
library(DDPQuiz3)
isGeneric(show)
isGeneric('show')
setwd("~/Dropbox/RAssignments/DeveloppingDataProductsProject")
install.packages("shiny")
library(shiny)
runApp()
runApp()
runApp()
x
runApp()
x <-0
runApp
runApp()
runApp(display.mode='showcase')
runApp(display.mode='showcase')
runApp(display.mode='showcase')
runApp(display.mode='showcase')
runApp(display.mode='showcase')
